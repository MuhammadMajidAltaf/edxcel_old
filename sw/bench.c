
#include <ed25519.h>
#include <global.h>
#include <assert.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define MESSAGE_LEN 32
#define SIGNATURE_LEN 64
#define KEY_LEN 32

#define MESSAGE_WORDS 	(MESSAGE_LEN/4)
#define SIGNATURE_WORDS (SIGNATURE_LEN/4)
#define KEY_WORDS 		(KEY_LEN/4)

//Return 1 if sig is ok, 0 if sig fails
inline int sw_verify(uint8_t *sig, uint8_t *msg, uint8_t *key)
{
	return ed25519_verify(sig, msg, 32, key);
}

uint8_t hw_verify_sync(uint8_t *sig, uint8_t *msg, uint8_t *key)
{
	//Find available EPU
	int i;
	uint32_t result;
	//uint8_t epu_idx = XL_AVAILABLE_IDX;
	uint8_t epu_idx = 0;
	assert (epu_idx != XL_AVAILABLE_NONE);
	
	
	//Load signature
	for (i=0;i<SIGNATURE_WORDS;i++)
		XL_EPU_SIG(epu_idx)[i] = ((uint32_t*)&sig[0])[i];
	
	//Load message
	for (i=0;i<MESSAGE_WORDS;i++)
		XL_EPU_MSG(epu_idx)[i] = ((uint32_t*)&msg[0])[i];
		
	//Load key	
	for (i=0;i<KEY_WORDS;i++)
		XL_EPU_KEY(epu_idx)[i] = ((uint32_t*)&key[0])[i];
	
	//Start computation
	XL_EPU_GO(epu_idx) = XL_GO_CODE;
		
	//Wait until calculation is done
	while(!XL_EPU_DONE(epu_idx));

	result = XL_EPU_DONE(epu_idx);
	printf("result was: %d\n", result);
	result = XL_EPU_DONE(epu_idx);
	printf("result was: %d\n", result);
	//Codes are 0 for busy, 1 for sig pass and 2 for sig fail
	return result == 1;
}

void enumerate_API()
{
	int i;
	
	for (i = 0;i<XL_NUM_EPU;i++)
	{
		
	}
}
int check_ok_sig()
{
		uint8_t sig32_arr [] = { 0xf2 , 0xff , 0xdf , 0xff , 0x9e , 0x00 , 0x6a , 0x0b , 0x83 , 
		                         0x9e , 0x2e , 0x5c , 0x79 , 0x61 , 0x2a , 0xcf , 0x50 , 0xf9 , 
		                         0xab , 0xe3 , 0xa3 , 0x9d , 0xa4 , 0x4f , 0x86 , 0x5f , 0xb4 , 
		                         0x30 , 0x6c , 0xbd , 0x15 , 0x17 , 0x2b , 0x02 , 0xfc , 0x33 , 
		                         0x41 , 0x41 , 0xf6 , 0xce , 0xdf , 0x44 , 0xc3 , 0xde , 0xdd , 
		                         0x2a , 0x26 , 0x22 , 0x79 , 0x4e , 0x42 , 0x92 , 0xf5 , 0x62 , 
		                         0xe3 , 0xd9 , 0x3f , 0x12 , 0x46 , 0x7a , 0x65 , 0x2c , 0x72 , 
		                         0x0e };
        uint8_t public_key [] = { 0x06 , 0xbf , 0x38 , 0x96 , 0xce , 0x20 , 0x45 , 0x60 , 0xe3 , 0x67 , 
                                  0x96 , 0xb0 , 0x6e , 0xea , 0xe3 , 0x72 , 0x15 , 0x2f , 0x4e , 0x71 , 
                                  0xbc , 0xa3 , 0x46 , 0x5e , 0x38 , 0x97 , 0xa3 , 0xcd , 0xa3 , 0xdd , 
                                  0x3d , 0x97 };
        uint8_t h_arr [] = { 0x4a , 0x91 , 0xfb , 0xa1 , 0xfd , 0xcb , 0x4b , 0xc2 , 0xe3 , 0xfa , 0x61 ,
                             0x0a , 0x40 , 0xcf , 0xfb , 0x8d , 0x4f , 0x8b , 0xc6 , 0xc7 , 0xd8 , 0x17 , 
                             0x03 , 0xf0 , 0x54 , 0x6d , 0xdd , 0x3e , 0x67 , 0xf3 , 0x0f , 0x07 };
	int result = hw_verify_sync(sig32_arr, h_arr, public_key);
	return result;
}

int check_bad_sig()
{
		uint8_t sig32_arr [] = { 0xf2 , 0xff , 0xdf , 0xff , 0x9e , 0x00 , 0x6a , 0x0b , 0x83 , 
		                         0x9e , 0x2e , 0x5c , 0x79 , 0x61 , 0x2a , 0xcf , 0x50 , 0xf9 , 
		                         0xab , 0xe3 , 0xa3 , 0x9d , 0xa4 , 0x4f , 0x86 , 0x5f , 0xb4 , 
		                         0x30 , 0x6c , 0xbd , 0x15 , 0x17 , 0x2b , 0x02 , 0xfc , 0x33 , 
		                         0x41 , 0x41 , 0xf6 , 0xce , 0xdf , 0x44 , 0xc3 , 0xde , 0xdd , 
		                         0x2a , 0x26 , 0x22 , 0x79 , 0x4e , 0x42 , 0x92 , 0xf5 , 0x62 , 
		                         0xe3 , 0xd9 , 0x3f , 0x12 , 0x46 , 0x7a , 0x65 , 0x2c , 0x73 , //0x73 is wrong 
		                         0x0e };
        uint8_t public_key [] = { 0x06 , 0xbf , 0x38 , 0x96 , 0xce , 0x20 , 0x45 , 0x60 , 0xe3 , 0x67 , 
                                  0x96 , 0xb0 , 0x6e , 0xea , 0xe3 , 0x72 , 0x15 , 0x2f , 0x4e , 0x71 , 
                                  0xbc , 0xa3 , 0x46 , 0x5e , 0x38 , 0x97 , 0xa3 , 0xcd , 0xa3 , 0xdd , 
                                  0x3d , 0x97 };
        uint8_t h_arr [] = { 0x4a , 0x91 , 0xfb , 0xa1 , 0xfd , 0xcb , 0x4b , 0xc2 , 0xe3 , 0xfa , 0x61 ,
                             0x0a , 0x40 , 0xcf , 0xfb , 0x8d , 0x4f , 0x8b , 0xc6 , 0xc7 , 0xd8 , 0x17 , 
                             0x03 , 0xf0 , 0x54 , 0x6d , 0xdd , 0x3e , 0x67 , 0xf3 , 0x0f , 0x07 };
	int result = hw_verify_sync(sig32_arr, h_arr, public_key);
	return result;
}

volatile uint32_t* dest;


void go()
{
	printf("ok sig result: %d\n", check_ok_sig());
	//printf("bad sig result: %d\n", check_bad_sig());
	//printf("ok sig result: %d\n", check_ok_sig());
	//printf("bad sig result: %d\n", check_bad_sig());
	
}


